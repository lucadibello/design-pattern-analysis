\section{Analysis of results}

After running the design pattern analysis tool on the entire \texttt{com.github.benmanes.caffeine.cache} package, the tool was able to find the usage of seven design patterns. The following list summarizes the design patterns found in the library:

\begin{itemize}
	\item \textbf{Factory Method}: Detected in 5 different classes, with a total of 7 factory methods identified. In \textit{Caffeine} is is used to create particular configuration of data structures, such as synchronous or asynchronous caches, or to create a certain type of cache node.

	\item \textbf{Singleton}: Found in 9 different classes, with a total of 9 singleton instances. Due to the versatility of the pattern, it has been used extensively in the library for various reasons. However, the analyzer was not able to detect usage of this pattern in the \texttt{NodeFactory} interface (refer to \autoref{par:nodefactory} for more details), hinting that is not reliable in certain complex cases.

	\item \textbf{Adapter}: Detected in 6 different classes, with 6 adapter classes detected. This pattern allows the library to use internally the interface of a passed object to perform certain operations, while exposing a different interface to the client. For instance, \texttt{BoundedPolicy} adapts the functionality of a \texttt{BoundedLocalCache} object to perform certain operations on the cache, while exposing a \texttt{Policy} interface to the client.

	\item \textbf{Decorator}: Identified in 3 different classes. \textit{Caffeine} library use this pattern to extend the functionality certain base classes. For example, the class \texttt{GuardedScheduler} decorates a \texttt{Scheduler} object to add additional functionality to the scheduler, while maintaining the original interface.

	\item \textbf{State}: This design pattern has been identified in 8 classes. This design pattern allows to encapsulate different behavioral states of an object in separate classes, allowing the object to change its behavior at runtime. Unfortunately, the scanner produces many false positives for this pattern, as it is difficult to distinguish between a state pattern and a simple delegation of functionality to another object. Please refer to \autoref{sec:false-positives} for more details.

	\item \textbf{Bridge}: Found in 4 classes, this design pattern allows to decouple the object abstraction from its implementation, allowing both to change independently. Unfortunately, the scanner also in this case produced many false-positives, please refer to \autoref{sec:false-positives} for more details.

	\item \textbf{Template Method}: Detected the use of this design pattern in 7 different classes. In most of the cases the library uses the template method in classes reguarding data structure definitions, in order to separate the logic of the data structure from the general logic, allowing subclasses to redefine certain behaviors. Unfortunately even in this case the scanner made some mistakes, refer to the \autoref{sec:false-positives} for more details.

\end{itemize}

\noindent Due to the size of the library, and the amount of design patterns detected, the report will only analyze the most interesing usages of the design patterns found. For each design pattern, the report will provide details on how the pattern is implemented and what value it brings to the architecture of the library.

\subsection{Creational Design Patterns}

\input{./contents/patterns/creational}

\subsection{Structural Design Patterns}

\input{./contents/patterns/structural}

\subsection{False Positives}
\label{sec:false-positives}

The scanner produces many false positives for the following \textit{State}, \textit{Bridge} and \textit{Template Method} design patterns. For example, the scanner detected the usage of the \textit{State} design pattern inside the \texttt{BoundedLocalCache}. This class implements a task-based approach to alter the state of the \textit{page replacement policy} for specific nodes. The class defines three kinds of task: \texttt{AddTask}, \texttt{UpdateTask} and \texttt{RemovalTask}. These task have a common structure: they all offer a single constructor method accepting a \texttt{Node<K, V>} object (subject on which the new policy will be applied) and they implement the \texttt{Runnable} interface. The \texttt{run} method (inherited from the \texttt{Runnable} interface) defines the behavior of the specific task. By extending the same interface, it is possible to store different kinds of task inside a common collection.

After further inspection, this structure represents the \textit{Command} design pattern, where each type of task represents a particular \textit{command} to alter the state of the cache \textit{page replacement policy}. This is also confirmed by the fact that after the creation of a specific task, the program appends it to a global buffer named \texttt{writeBuffer}. This buffer will then be used to pull tasks and execute them at specific times (i.e. after a write operation). This represents the essence of the \textit{Command} design pattern, and was detected as the \textit{State} design pattern probably due to the similar taxonomy.

Also the \textit{Bridge} design pattern was wrongly detected in several places across the codebase, probably due to the extensive use of interfaces and abstract classes that made the design pattern detection task more complex, reducing the accuracy of the results. Furthermore, a similar issue happened with the detection of the \textit{Template Method} design pattern. For example, the method \texttt{ExpandOrRetry} of the \texttt{StripedBuffer} class was flagged as \textit{Template Method}, even if was clearly a utility method as it was marked as \textit{final}. Since subclasses do not allow to alter the behavior of the method, confirms that the \textit{Template Method} design pattern is not used.

In conclusion, due to the size and complexity of this library, it was expected that \textit{pattern4j} would produce false-positives, particularly for more flexible design patterns that can be easily manipulated to fit the architectural needs without affecting the benefits the pattern brings to the codebase (e.g., behavioral design patterns). Additionally, due to the extensive use of design patterns in order to provide a well-structured codebase, the design pattern detection task was expected to be more difficult. As a rough estimation, around 70\% of the detected instances were correctly classified by the tool.

\subsection{Expected Patterns}

The \textit{Caffeine} library is an important open-source project, that has been around for nearly 10 years (first commit on the \displaydate{caffeinerelease}). From the start \textit{Caffeine} was expected to be a well-structured library with clear separation of concerns and a good usage of design patterns; assumptions which were all confirmed during the analysis made throughout the previous sections. Strangely, was expected that \texttt{pattern4j} would detect the usage of some additional design patterns, which are commonly used in utility libraries of this kind. The following list outlines the missing design patterns:

\begin{itemize}
	\item \textit{Observer} design pattern: in order to notify clients of changes in the cache (i.e. evictions, insertions, etc.), the library should implement the observer pattern.
	\item \textit{Command} design pattern: the library should use the command pattern to encapsulate requests as objects, allowing to parameterize clients with queues, requests and operations.
\end{itemize}

\noindent After further analysis of the false-positives produced by the scanner, was possible to identify the use of the \textit{Command} design pattern inside the \texttt{BoundedLocalCache} class (for more details, refer to \autoref{sec:false-positives}). On the other hand, by a manual inspection of the codebase (searching for common keywords used commonly in the \textit{Observer} pattern, i.e. \textit{listener}, \textit{observer}) it was not possible to find any implementation of the \textit{Observer} design pattern, but rather only the use of certain related methods (i.e., \textit{addListener}) offered by other project dependencies.

