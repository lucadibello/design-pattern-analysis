\section{Introduction}

This assignment asks to use the design pattern detection tool \href{https://users.encs.concordia.ca/~nikolaos/pattern\_detection.html}{pattern4j} to automatically detect the usage of design patterns in a chosen open-source Java project and document the result in a report. The tool is able to scan Java bytecode\footnote{Set of instructions produced during compilation that can be executed by the \textit{Java Virtual Machine} (JVM)} files and detect the usage of 13 different design patterns.

Furthermore, the chosen open-source project must satisfy the following requirements: at least 100 stars, 100 forks, 10 open issues, and at least 50'000 lines of Java code (comments included). In order to find a valid project, the GitHub search feature was used as it allows to filter repositories based on some predefined filters. For example, to find a Java project that satisfies the requirements listed above, the following query can be used:

\begin{verbatim}
  stars:>100 forks:>100 language:java
\end{verbatim}

\noindent However, since the search filters available on GitHub cannot filter by LOC\footnote{Acronym for \textit{Lines of Code}}, the web application available at \href{https://codetabs.com/count-loc/count-loc-online.html}{codetabs.com/count-loc} was used in order to lines of code of a project without having to clone it locally.

\subsection{Project selection}

In order to learn more about the design patterns used in famous Java projects, the search was focused on active projects, with a large community and a good number of stars and forks. After some research, the following projects were initially selected:

\begin{itemize}
	\item \href{https://github.com/projectlombok/lombok}{projectlombok/lombok}: Library containing a set of useful Java annotations aimed at reducing boilerplate code in Java applications. It has 30.7k stars, 3.7k forks, and used actively in many famous projects. It has around 98k lines of Java code (comments excluded).

	      However, this project was later discarded as it use the \texttt{Ant} build system, which I am not familiar with. In order to avoid potential issues thus being able to focus on the main task of the assignment, I discarded this project and started looking for others using more familiar build systems such as \texttt{Maven} or \texttt{Gradle}.

	\item \href{https://github.com/ReactiveX/RxJava}{ReactiveX/RxJava}: Library for composing asynchronous and event-based programs using observable sequences, providing also bindings for different languages and platforms. It library has 19.9k stars, 2.9k forks, and has about 395k lines of Java code (comments excluded).

	      Initially, the assignment was started with this project in mind but, unfortunately, this project was discarded later on due to major issues encountered during the compilation phase. \textit{RxJava} was using the \texttt{Gradle} build system, but the build process terminated with an unexpected error that was not possible to solve in a reasonable amount of time.

	\item \href{https://github.com/ben-manes/caffeine}{benmanes/caffeine}: A high-performance caching library for Java used in many famous projects such as \textit{Apache Kafka}, \textit{Cassandra} and \textit{Neo4J}. It has 15.8k starts, 1.6k forks and has around 100k LOC. Unfortunately, representing a mature and well-maintained Java library only had 4 open issues on GitHub (as on the \displaydate{projectdate}), rather than the required 10. After inquiring the teaching assistant, it was decided that this requirement could be overlooked as the low number of open issues could be attributed to the maturity of the project.

	      As this project completely aligns with the project requirements and the personal objectives fixed for this assignment, it was decided to use this project for the assignment. Additionally, \textit{Caffeine} uses the \textit{Gradle} build system, which this time allowed to build the project without any complication. Refer to \autoref{sec:building} for more details about the building process.

\end{itemize}

\subsection{High-level overview of the project structure}

The \textit{Caffeine} library, apart from offering an high-performance caching library, offers two adapters for the \textit{Google Guava} and \textit{JCache} libraries, allowing to easily integrate \textit{Caffeine} with other existing projects.

The project is split into several packages, but the main packages of the library are the following:

\begin{itemize}
	\item \texttt{com.github.benmanes.caffeine.cache}: Main package of the library, contains the core classes of the caching library.
	\item \texttt{com.github.benmanes.caffeine.cache.guava}: Contains classes that provide compatibility with the Google Guava caching library (documentation available \href{https://github.com/ben-manes/caffeine/wiki/Guava"}{here}).
	\item \texttt{com.github.benmanes.caffeine.cache.jcache}: Adapter for the \textit{JSR-107 JCache} caching API (documentation available \href{https://github.com/ben-manes/caffeine/wiki/JCache}{here})
\end{itemize}

\noindent This report describes the design patterns found in the core library of the project (\texttt{cache} package) leveraging \texttt{pattern4j} tool. The report will focus on the core library of the project, avoiding the analysis of the \textit{Google Guava} and \textit{JCache} since they represent only extensions of the core library, providing only compatibility with other libraries.

\subsection{Building and analyzing resulting Java bytecode}
\label{sec:building}

The project can be easily built using the provided \href{https://docs.gradle.org/current/userguide/gradle_wrapper.html}{Gradle Wrapper} script. This script will download the required version of \textit{Gradle}, configure the project, start the build process. To do so, the following command has been used:

\begin{lstlisting}[language=bash, caption={Building the \textit{Caffeine} library using the provided \textit{Gradle Wrapper} script}]
              cd caffeine && ./gradlew build -x test -x javadoc
\end{lstlisting}

\noindent The additional flags \texttt{-x test} and \texttt{-x javadoc} are used to skip the execution of the tests and the generation of the Java documentation. These two steps are quite time-consuming and would not add any value to the report. For these reasons, the two steps have been disabled during the build process. The compiled classes of the core library are located in the directory \texttt{caffeine/build/classes/java/main}. These files will then be analyzed by the \texttt{pattern4j} tool in order to detect the usage of design patterns.

To start the scanner in headless mode, the following console command can be used:

\begin{lstlisting}[language=bash, caption={Bash command to start the pattern4j design pattern analysis in headless mode}]
            java -Xms32m -Xmx512m -jar ./tools/pattern4.jar \
              -target "./caffeine/build/classes/java/main" \
              -output "./results/out.xml"
\end{lstlisting}

\noindent The tool will analyze the bytecode produced during compilation and return an XML file containing the detected design patterns and their locations in the code. It is also possible to start the GUI version of the tool by simply removing the \texttt{target} and \texttt{output} flags.

To streamline both building and analysis processes, the repository contains a \texttt{Makefile} that allows to execute the following targets: \texttt{build}, \texttt{clean}, \texttt{analyze}, \texttt{analyze-gui}.

