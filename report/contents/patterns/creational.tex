\subsubsection{Factory Method}

The tool detected the usage of the \textit{Factory Method} design pattern in 5 different instances. This pattern is used to encapsulate the creation of objects, allowing subclasses to alter the type of objects that will be created. In the following paragraph, each instance will be briefly presented and analyzed. Due to the large amount of instances found, only 3 out of the 5 instances will be presented as they are the most representative of the pattern usage or showcase interesting implementations of the pattern.

\paragraph{NodeFactory interface} This interface represents a particular implementation of the \textit{Factory Method} pattern. The interface defines a two static constructor methods \texttt{newFactory} to create new \texttt{NodeFactory} instances. The method signatures are defined in \autoref{lst:nodefactory}.

\begin{lstlisting}[language=Java, caption={NodeFactory interface static constructor methods}, captionpos=b, label={lst:nodefactory}]
static NodeFactory<Object, Object> newFactory(String className)
static <K, V> NodeFactory<K, V> newFactory(Caffeine<K, V> builder, boolean isAsync)
\end{lstlisting}

\noindent These two static constructor methods leverage the \texttt{Singleton} design pattern in order to provide a single instance of the \texttt{NodeFactory} per className: if the \texttt{newFactory} method is called with the same \texttt{className} parameter (either explictly passed as parameter or embedded in the \texttt{builder} object), the same instance of the \texttt{NodeFactory} will be returned. To keep track of different instances, both methods access internally a static \texttt{ConcurrentMap}, which pairs the provided \texttt{className} with the \texttt{NodeFactory} instance: if the \texttt{className} is already present in the map, the method will simply return the instance, otherwise it will create a new instance, add it to the map and return it. The code responsible for this behavior is presented in \autoref{lst:nodefactorysingleton}.

It is important to highlight that the design pattern scanner, probably due to the complexity of the implementation, did not detect the this particular usage of the \textit{Singleton} design pattern.

\begin{lstlisting}[language=Java, caption={NodeFactory singleton design pattern implementation using a static \texttt{ConcurrentMap} instance}, captionpos=b, label={lst:nodefactorysingleton}]
    var factory = FACTORIES.get(className);
    if (factory == null) {
      factory = FACTORIES.computeIfAbsent(
        className, NodeFactory::newFactory
      );
    }
    return (NodeFactory<K, V>) factory;
\end{lstlisting}

\noindent The \texttt{NodeFactory} interface two abstract factory methods to create new cache nodes (\texttt{Node} objects) of different types. The method signatures are defined in \autoref{lst:nodefactorymethods}.

\begin{lstlisting}[language=Java, caption={NodeFactory abstract factory methods to create \texttt{Node} objects}, captionpos=b, label={lst:nodefactorymethods}]
Node<K, V> newNode(K key, ReferenceQueue<K> ref, V value,
  ReferenceQueue<V> valueReferenceQueue, int weight, long now);
Node<K, V> newNode(Object keyReference, V value,
  ReferenceQueue<V> valueReferenceQueue, int weight, long now);
\end{lstlisting}

\noindent Since both methods are \texttt{abstract}, each concrete implementation of the \texttt{NodeFactory} interface must define its own implementation of these methods, allowing to return different instances of the \texttt{Node} interface. This is a clear example of the \textit{Factory Method} pattern usage.

As example, the \texttt{BoundedLocalCache} cache internally use a \texttt{NodeFactory} factory to create new cache nodes. This allows to easily switch between different implementations of the \texttt{Node} interface, depending on the cache type.

\paragraph{LinkedDeque interface} This interface specify a linked list implementation of a deque. The interface apart from defining the methods to manage the deque, it also defines two abstract factory methods that return new instances of the \textit{PeekingIterator} interface. The methods are defined as follows:

\begin{lstlisting}
  PeekingIterator<E> iterator();
  PeekingIterator<E> descendingIterator();
\end{lstlisting}

\noindent Concrete implementations will need to implement these methods and return new custom iterators: since the \textit{PeekingIterator} is an interface, the \textit{Factory Method} pattern is used to encapsulate multiple possible implementations of the iterator.

\paragraph{Other instances} The tool detected the usage of the \textit{Factory Method} pattern in the following three other locations: \textit{AsyncLocalCache::synchronous}, \textit{AsyncLocalCache::policy} and  \textit{StripedBuffer::create(E)}. These are all valid implementations of the design pattern, but are not particularly interesting as they are similar to the ones presented above.

\subsubsection{Singleton}
\label{sec:singleton}

The \textit{Singleton} pattern is used to ensure that a particular class has only one instance. To do so, the class usually defines a private constructor in order to hide the constructor from other classes, and a static method to serve as an entry point to the instance: the method will create the instance if it does not exist, or return the existing instance if it does. The tool detected the usage of the \textit{Singleton} pattern in the \textit{Caffeine} library in 9 different instances. Since all instances are essentially the same, I will present the \textit{Weighter} interface as an example of the pattern usage.

In this particular case, in order to prevent the creation of multiple \texttt{Weigher<K, V>} instances, the \textit{Caffeine} library implements the \textit{Singleton} pattern by leveraging a common trick involving \textit{enum} types. The \textit{SingletonWeighter} enum implements the \textit{Weigher} interface, and defines a single instance of the enum named \texttt{INSTANCE}. Thanks to the nature of \textit{enum} types, the \texttt{INSTANCE} instance is guaranteed to be unique. The \textit{Weigher} interface provides a static method to return the singleton instance of the \texttt{SingletonWeigher} enum. The method signature is defined as follows:

\begin{lstlisting}[language=Java]
enum SingletonWeigher implements Weigher<Object, Object> {
  INSTANCE;
  ...
}

static <K, V> Weigher<K, V> singletonWeigher() {
  @SuppressWarnings("unchecked")
  var instance = (Weigher<K, V>) SingletonWeigher.INSTANCE;
  return instance;
}
\end{lstlisting}

\noindent This kind of \textit{Singleton} pattern implementation is found in all 9 instances detected by the tool. The other instances are not presented in this report as they would not add any value to the analysis.

I decided to present the \textit{Weighter} interface as an example of the \textit{Singleton} pattern usage, as it also exhibit some characteristics of the \textit{Factory Method} pattern, offering custom methods to encapsulate the creation of different kinds of \textit{Weighter} objects. The method signatures are defined as follows:

\begin{lstlisting}[language=Java]
static <K, V> Weigher<K, V> singletonWeigher() { ... }
static <K, V> Weigher<K, V> boundedWeigher(Weigher<K, V> w) { }
\end{lstlisting}

\noindent However, in order to be a correct factory method implementation, subclasses should be able to implement the \textit{Weigher} interface and define their own custom implementations of the factory methods presented above, allowing to return different instances of the \textit{Weigher} interface. This is not possible as both methods are \textit{static}, thus they cannot be overridden by subclasses.
