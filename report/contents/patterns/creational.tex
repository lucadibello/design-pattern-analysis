\subsubsection{Factory Method}
\label{par:nodefactory}

The tool detected the usage of the \textit{Factory Method} design pattern in 5 different instances. This pattern is used to encapsulate the creation of objects, allowing subclasses to alter the type of objects that will be created. In this section will be presented only the \texttt{NodeFactory} instance as it represents the most complete and interesting example of the pattern usage.

The \texttt{NodeFactory} interface represents a particular implementation of the \textit{Factory Method} pattern. The interface defines a two static constructor methods \texttt{newFactory} to create new \texttt{NodeFactory} instances. The method signatures are defined in \autoref{lst:nodefactory}.

\begin{lstlisting}[language=Java, caption={NodeFactory interface static constructor methods}, captionpos=b, label={lst:nodefactory}]
static NodeFactory<Object, Object> newFactory(String className)
static <K, V> NodeFactory<K, V> newFactory(Caffeine<K, V> builder, boolean isAsync)
\end{lstlisting}

\noindent These two static constructor methods leverage the \texttt{Singleton} design pattern in order to provide a single instance of the \texttt{NodeFactory} per class name: if the \texttt{newFactory} method is called with the same \texttt{className} parameter (either explictly passed as parameter or embedded in the \texttt{builder} object), the same instance of the \texttt{NodeFactory} will be returned. To keep track of different instances, both methods access internally a static \texttt{ConcurrentMap}, which pairs the provided \texttt{className} with the \texttt{NodeFactory} instance: if the \texttt{className} is already present in the map, the method will simply return the instance, otherwise it will create a new instance, add it to the map and return it. The code responsible for this behavior is presented in \autoref{lst:nodefactorysingleton}.

It is important to highlight that the design pattern scanner, probably due to the complexity of the implementation, did not detect the this particular usage of the \textit{Singleton} design pattern.

\begin{lstlisting}[language=Java, caption={NodeFactory singleton design pattern implementation using a static \texttt{ConcurrentMap} instance}, captionpos=b, label={lst:nodefactorysingleton}]
    var factory = FACTORIES.get(className);
    if (factory == null) {
      factory = FACTORIES.computeIfAbsent(
        className, NodeFactory::newFactory
      );
    }
    return (NodeFactory<K, V>) factory;
\end{lstlisting}

\noindent The \texttt{NodeFactory} interface two abstract factory methods to create new cache nodes (\texttt{Node} objects) of different types. The method signatures are defined in \autoref{lst:nodefactorymethods}.

\begin{lstlisting}[language=Java, caption={NodeFactory abstract factory methods to create \texttt{Node} objects}, captionpos=b, label={lst:nodefactorymethods}]
Node<K, V> newNode(K key, ReferenceQueue<K> ref, V value,
  ReferenceQueue<V> valueReferenceQueue, int weight, long now);
Node<K, V> newNode(Object keyReference, V value,
  ReferenceQueue<V> valueReferenceQueue, int weight, long now);
\end{lstlisting}

\noindent Since both methods are \texttt{abstract}, each concrete implementation of the \texttt{NodeFactory} interface must define its own implementation of these methods, allowing to return different instances of the \texttt{Node} interface. This is a clear example of the \textit{Factory Method} pattern usage.

As example, the \texttt{BoundedLocalCache} cache internally use a \texttt{NodeFactory} factory to create new cache nodes. This allows to easily switch between different implementations of the \texttt{Node} interface, depending on the cache type.

\subsubsection{Singleton}
\label{sec:singleton}

The \textit{Singleton} pattern is used to ensure that a particular class has only one instance. To address this requirement, the class usually defines a private constructor (to hide the constructor method from clients), and a static method to serve as the new entry point to the instance. This method will try to lazily create the instance, if it does not exist yet, and return it.

The tool detected the usage of the \textit{Singleton} pattern in the \textit{Caffeine} library in 9 different instances. Since in all detected instances the pattern is implemented in similar ways, I will present only one instance where the pattern is used in a more interesting way.

\paragraph{Weigher interface and SingletonWeighter enum} The \textit{Weigher} interface is used to calculate the weight of a cache entry. In order to prevent the creation of multiple \texttt{Weigher<K, V>} instances, the \textit{Caffeine} library implements the \textit{Singleton} pattern by leveraging a very common Java trick involving an \textit{enum} type named \texttt{SingletonWeighter}. The \textit{Singleton} enum is defined in \autoref{lst:singletonweigher}.

\begin{lstlisting}[language=Java, caption={\texttt{SingletonWeigher} enum definition}, captionpos=b, label={lst:singletonweigher}]
enum SingletonWeigher implements Weigher<Object, Object> {
  INSTANCE;
  @Override public int weigh(Object key, Object value) {
    return 1;
  }
}
\end{lstlisting}

\noindent The \textit{SingletonWeighter} enum implements the \textit{Weigher} interface, and defines a single entry named \texttt{INSTANCE}, which is of type \texttt{SingletonWeigher}. Since the \texttt{SingletonWeighter} enum implements the \texttt{Weigher} interface, the \texttt{INSTANCE} entry is also of type \texttt{Weigher<Object, Object>}, effectively making it a singleton instance of the \texttt{Weigher} interface. This is only possible due to the intrinsic nature of \textit{enum} types, where each entry is guaranteed to be unique and only instantiated once.

In order to retrieve the singleton instance in a more concise way, the method \texttt{singletonWeigher} performs an unchecked cast to the \texttt{Weigher<K, V>} type, effectively returning the singleton instance:

\begin{lstlisting}[language=Java, caption={SingletonWeigher shorthand method to return the singleton instance using an unchecked cast}, captionpos=b, label={lst:singletonweigher}]
static <K, V> Weigher<K, V> singletonWeigher() {
  @SuppressWarnings("unchecked")
  var instance = (Weigher<K, V>) SingletonWeigher.INSTANCE;
  return instance;
}
\end{lstlisting}

\noindent The report presents the \textit{Weighter} interface as an example of the \textit{Singleton} pattern usage, as it also exhibit some characteristics of the \textit{Factory Method} pattern, offering custom methods that encapsulate the creation of different kinds of \textit{Weighter} objects. The method signatures are defined in \autoref{lst:weigherfactorymethods}.

\begin{lstlisting}[language=Java, caption={Weigher interface factory methods}, captionpos=b, label={lst:weigherfactorymethods}]
static <K, V> Weigher<K, V> singletonWeigher() { ... }
static <K, V> Weigher<K, V> boundedWeigher(Weigher<K, V> w) { }
\end{lstlisting}

\noindent However, in order to be a correct \textit{Factory Method} design pattern implementation, subclasses should be able to implement the \textit{Weigher} interface and define their own custom implementations of the factory methods presented above, allowing to return different instances of the \textit{Weigher} interface. This is not possible as both methods are \textit{static}, thus not allowing subclasses to alter the return type of the methods via inheritance as required by the design pattern.

