\subsubsection{Factory Method}
\label{par:nodefactory}

The tool detected the usage of the \textit{Factory Method} design pattern in 5 different instances. This pattern is used to encapsulate the creation of objects, allowing subclasses to return different instances of the same type using polymorphism. The pattern is used in the \textit{Caffeine} library to create particular configurations of data structures, such as synchronous or asynchronous caches, or to create particular types of cache node objects.

For example, the \texttt{NodeFactory} interface represents a particular implementation of the \textit{Factory Method} pattern. It defines a two static constructor methods \texttt{newFactory} to create new \texttt{NodeFactory} instances based on a specified class name. The method signatures are defined in \autoref{lst:nodefactory}.

\begin{lstlisting}[language=Java, caption={\texttt{NodeFactory} interface static constructor methods}, captionpos=b, label={lst:nodefactory}]
static NodeFactory<Object, Object> newFactory(String className)
static <K, V> NodeFactory<K, V> newFactory(Caffeine<K, V> builder, boolean isAsync)
\end{lstlisting}

\noindent These two static constructors leverage the \textit{Singleton} design pattern in order to provide a single instance of the \texttt{NodeFactory} per class name. This behavior is achieved by using a static \texttt{ConcurrentMap} to store the instances of the \texttt{NodeFactory} class linked to the class name (passed explicitly via parameter, or embedded in the \texttt{builder} object). This way, the method can simply return the instance if it is already present in the map, or create a new one if it does not exist yet. The code responsible for this behavior is presented in \autoref{lst:nodefactorysingleton}.

It is important to highlight that the design pattern scanner, probably due to the complexity of the implementation, did not detect the usage of the \textit{Singleton} design pattern in the \texttt{NodeFactory} interface. This is a clear example of the limitations of the tool, as the pattern is clearly implemented in the codebase.

\begin{lstlisting}[language=Java, caption={\texttt{NodeFactory} \textit{Singleton} design pattern implementation using a static \texttt{ConcurrentMap} instance}, captionpos=b, label={lst:nodefactorysingleton}]
    var factory = FACTORIES.get(className);
    if (factory == null) {
      factory = FACTORIES.computeIfAbsent(
        className, NodeFactory::newFactory
      );
    }
    return (NodeFactory<K, V>) factory;
\end{lstlisting}

\noindent Furthermore, the \texttt{NodeFactory} interface also defines two abstract factory methods to create new cache nodes (\texttt{Node} objects) of different types. The method signatures are defined in \autoref{lst:nodefactorymethods}.

\begin{lstlisting}[language=Java, caption={\texttt{NodeFactory} abstract factory methods to create \texttt{Node<K,V>} objects}, captionpos=b, label={lst:nodefactorymethods}]
Node<K, V> newNode(K key, ReferenceQueue<K> ref, V value,
  ReferenceQueue<V> valueReferenceQueue, int weight, long now);
Node<K, V> newNode(Object keyReference, V value,
  ReferenceQueue<V> valueReferenceQueue, int weight, long now);
\end{lstlisting}

\noindent Since both methods are \texttt{abstract}, each concrete implementation of the \texttt{NodeFactory} interface must define its own implementation of these methods, allowing to return different instances of the \texttt{Node} interface. This is a clear example of the \textit{Factory Method} pattern usage.

As example, the \texttt{BoundedLocalCache} cache internally use a \texttt{NodeFactory} factory to create new cache nodes. This allows to easily switch between different implementations of the \texttt{Node} interface, depending on the cache type.

\subsubsection{Singleton}
\label{sec:singleton}

The \textit{Singleton} pattern is used to ensure that a particular class has only one instance. To address this requirement, the class usually defines a private constructor (to hide the constructor method from clients), and a static method to serve as the new entry point to the instance. This method will try to lazily create the instance, if it does not exist yet, and return it.

The tool detected the usage of the \textit{Singleton} pattern in the \textit{Caffeine} library in 9 different instances. Since in all detected instances the pattern is implemented in similar ways, I will present only one instance where the pattern is used in a more interesting way.

The \textit{Weigher} interface is used to calculate the weight of a given cache node. In order to prevent the creation of multiple \texttt{Weigher<K, V>} instances, the \textit{Caffeine} library implements the \textit{Singleton} pattern by leveraging a very common Java trick involving an \textit{enum} type, which in this case is named \texttt{SingletonWeighter}. The enum definition is available in \autoref{lst:singletonweigher}.

\begin{lstlisting}[language=Java, caption={\texttt{SingletonWeigher} enum definition}, captionpos=b, label={lst:singletonweigher}]
enum SingletonWeigher implements Weigher<Object, Object> {
  INSTANCE;
  // dummy weigh method
  @Override public int weigh(Object key, Object value) {
    return 1;
  }
}
\end{lstlisting}

\noindent The \textit{SingletonWeighter} enum implements the \textit{Weigher} interface, and defines a single entry named \texttt{INSTANCE}, which is of type \texttt{SingletonWeigher}. Since the \texttt{SingletonWeighter} enum implements the \texttt{Weigher} interface, the \texttt{INSTANCE} entry is also of type \texttt{Weigher<Object, Object>}, effectively making it a singleton instance of the \texttt{Weigher} interface. This is only possible due to the intrinsic nature of \textit{enum} types, where each entry is guaranteed to be unique and only instantiated once.

In order to retrieve the singleton instance in a more concise way, the \texttt{Weigher} interface offers a static \texttt{singletonWeigher()} utility method that simply reads the \texttt{INSTANCE} entry from the \texttt{SingletonWeigher} enum and performs an unchecked cast to the \texttt{Weigher<K, V>} type, effectively returning the singleton instance:

\begin{lstlisting}[language=Java, caption={SingletonWeigher shorthand method to return the singleton instance using an unchecked cast}, captionpos=b, label={lst:singletonweigher}]
static <K, V> Weigher<K, V> singletonWeigher() {
  @SuppressWarnings("unchecked")
  var instance = (Weigher<K, V>) SingletonWeigher.INSTANCE;
  return instance;
}
\end{lstlisting}

\noindent Additonally, this interface exhibit also some characteristics of the \textit{Factory Method} pattern, offering custom methods that encapsulate the creation of different kinds of \textit{Weigher} objects. The method signatures are defined in \autoref{lst:weigherfactorymethods}.

\begin{lstlisting}[language=Java, caption={\texttt{Weigher} interface utility methods to create different kinds of \texttt{Weigher<K,V>}}, captionpos=b, label={lst:weigherfactorymethods}]
static <K, V> Weigher<K, V> singletonWeigher()
static <K, V> Weigher<K, V> boundedWeigher(Weigher<K, V> w)
\end{lstlisting}

\noindent However, in order to be a correct \textit{Factory Method} design pattern implementation, subclasses should be able to implement the \textit{Weigher} interface and define their own custom implementations of the factory methods presented above, allowing them to leverage polymorphism in order to return different instances of the \textit{Weigher} interface. This is not possible as both methods are \textit{static}, thus not allowing subclasses to alter the return type of the methods via inheritance as required by the design pattern.

